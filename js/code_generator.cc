// Copyright (c) 2010-2011 SameGoal LLC.
// All Rights Reserved.
// Author: Andy Hochhaus <ahochhaus@samegoal.com>

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "code_generator.h"

#include <string>
#include <iostream>  // NOLINT
#include <sstream>  // NOLINT

#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/printer.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream.h>
#include <google/protobuf/stubs/common.h>
#include <google/protobuf/wire_format.h>
#include <google/protobuf/wire_format_lite_inl.h>

#include "int64_encoding.pb.h"
#include "javascript_package.pb.h"

namespace google { namespace protobuf { namespace compiler { namespace js {
using internal::WireFormat;
using internal::WireFormatLite;

namespace {

string ToCamelCase(const string& input, bool lower_first) {
  bool capitalize_next = !lower_first;
  string result;
  result.reserve(input.size());

  for (int i = 0; i < input.size(); i++) {
    if (input[i] == '_') {
      capitalize_next = true;
    } else if (capitalize_next) {
      // Note:  I distrust ctype.h due to locales.
      if ('a' <= input[i] && input[i] <= 'z') {
        result.push_back(input[i] - 'a' + 'A');
      } else {
        result.push_back(input[i]);
      }
      capitalize_next = false;
    } else {
      result.push_back(input[i]);
    }
  }

  // Lower-case the first letter.
  if (lower_first && !result.empty() && 'A' <= result[0] && result[0] <= 'Z') {
      result[0] = result[0] - 'A' + 'a';
  }

  return result;
}

int sizeOfVarInt(long long v) {
  int n = 0;
  do {
    v >>= 7;
    n++;
  } while (v > 0);
  return n;
}

} // namespace

CodeGenerator::CodeGenerator(const std::string &name)
    : name_(name) {}

CodeGenerator::~CodeGenerator() {}

bool CodeGenerator::Generate(
    const google::protobuf::FileDescriptor *file,
    const std::string &/* parameter */,
    google::protobuf::compiler::OutputDirectory *output_directory,
    std::string *error) const {

  const std::string file_name = file->name();
  std::string output_file_name = file->name();
  std::size_t loc = output_file_name.rfind(".");
  output_file_name.erase(loc, output_file_name.length() - loc);
  output_file_name.append(".pb.js");

  google::protobuf::internal::scoped_ptr<
      google::protobuf::io::ZeroCopyOutputStream> output(
          output_directory->Open(output_file_name));
  google::protobuf::io::Printer printer(output.get(), '$');
  printer.Print(
      "\"use strict\"\n"
      "// Generated by the protocol buffer compiler.  DO NOT EDIT!\n");
  printer.Print("// source: $file_name$\n", "file_name", file_name);
  printer.Print("\n");
  printer.Print(
      "/**\n"
      " * @fileoverview Generated Protocol Buffer code for file $file_name$.\n"
      " */\n", "file_name", file_name);

  for (int i = 0; i < file->message_type_count(); ++i) {
    CodeGenerator::GenDescriptor(
        file->message_type(i),
        &printer);
  }

  for (int i = 0; i < file->enum_type_count(); ++i) {
    CodeGenerator::GenEnum(
        file->enum_type(i),
        &printer);
  }

  printer.Print("function sizeOfVarInt(v) {\n");
  printer.Indent();
  printer.Print("var n = 0\n");
  printer.Print("do {\n");
  printer.Indent();
  printer.Print("v >>= 7\n");
  printer.Print("n++\n");
  printer.Outdent();
  printer.Print("} while (v > 0)\n");
  printer.Print("return n\n");
  printer.Outdent();
  printer.Print("}\n");
  printer.Print("\n");

  printer.Print("function sizeOfString(s) {\n");
  printer.Indent();
  printer.Print("var b = 0, i = 0, c\n");
  printer.Print("while(c=s.charCodeAt(i++)){b+=c>>11?3:c>>7?2:1}\n");
  printer.Print("return sizeOfVarInt(b) + b\n");
  printer.Outdent();
  printer.Print("}\n");
  printer.Print("\n");

  for (int i = 0; i < file->message_type_count(); ++i) {
    const google::protobuf::Descriptor *message = file->message_type(i);
    printer.Print("exports.$name$ = $name$\n",
                  "name", message->name());
  }
  for (int i = 0; i < file->enum_type_count(); ++i) {
    const google::protobuf::EnumDescriptor *enum_desc = file->enum_type(i);
    printer.Print("exports.$name$ = $name$\n",
                  "name", enum_desc->name());
  }

  if (printer.failed()) {
    *error = "CodeGenerator detected write error.";
    return false;
  }

  return true;
}

void CodeGenerator::GenDescriptor(
    const google::protobuf::Descriptor *message,
    google::protobuf::io::Printer *printer) 
{
  printer->Print("function $name$() {\n",
                 "name", message->name());
  printer->Indent();
  printer->Print("this.sizeInBytes = undefined\n");
  for (int i = 0; i < message->field_count(); ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);
    printer->Print("this.$name$ = undefined\n",
                   "name", field->camelcase_name());
  }
  printer->Outdent();
  printer->Print("}\n");

  CodeGenerator::GenMessage_fromReader(message, printer);
  CodeGenerator::GenMessage_builder(message, printer);

  printer->Print("$name$.prototype = {\n",
                 "name", message->name());
  printer->Indent();

  CodeGenerator::GenMessage_toWriter(message, printer);

  printer->Outdent();
  printer->Print("}\n");

  CodeGenerator::GenMessage_sizeInBytes(message, printer);

  CodeGenerator::GenMessageBuilder(message, printer);

  for (int i = 0; i < message->nested_type_count(); ++i) {
    const google::protobuf::Descriptor *nested_type = message->nested_type(i);
    printer->Print("$name$.$nested_name$ = function(){\n",
                   "name", message->name(),
                   "nested_name", nested_type->name());
    printer->Indent();
    CodeGenerator::GenDescriptor(
        nested_type,
        printer);
    printer->Print("return $nested_name$\n",
                   "nested_name", nested_type->name());
    printer->Outdent();
    printer->Print("}()\n");
  }

  for (int i = 0; i < message->enum_type_count(); ++i) {
    const google::protobuf::EnumDescriptor *enum_desc = message->enum_type(i);
    printer->Print("$name$.$nested_name$ = {\n",
                   "name", message->name(),
                   "nested_name", enum_desc->name());
    printer->Indent();
    for (int i = 0; i < enum_desc->value_count(); ++i) {
      std::string format = "$key$: $value$,\n";
      if (i == enum_desc->value_count() - 1) {
        format = "$key$: $value$\n";
      }
      std::ostringstream number;
      number << enum_desc->value(i)->number();
      printer->Print(format.c_str(),
                     "key", enum_desc->value(i)->name(),
                     "value", number.str());
    }
    printer->Outdent();
    printer->Print("}\n");
  }

  printer->Print("\n");
}

void CodeGenerator::GenMessage_fromReader(
    const google::protobuf::Descriptor *message,
    google::protobuf::io::Printer *printer) 
{
  printer->Print("$name$.fromReader = function(r) {\n",
                 "name", message->name());
  printer->Indent();
  printer->Print("var m = new $name$()\n",
                 "name", message->name());

  if (message->field_count() > 0) {

    printer->Print("var t\n");
    printer->Print("loop: while (t = r.readVarInt()) {\n",
                   "name", message->name());
    printer->Indent();
    printer->Print("switch (t) {\n");
    printer->Indent();

    for (int i = 0; i < message->field_count(); ++i) {
      const google::protobuf::FieldDescriptor *field = message->field(i);

      std::string tag = std::to_string(WireFormatLite::MakeTag(field->number(), WireFormat::WireTypeForField(field)));
      std::string field_name = field->camelcase_name();

      printer->Print("case $tag$: {\n",
                     "tag", tag);
      printer->Indent();

      if (field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE) {
        printer->Print("var limit = r.pushLimit(r.readVarInt())\n");

        if (field->label() == google::protobuf::FieldDescriptor::LABEL_REPEATED) {
          printer->Print("var a = this.$name$ || (this.$name$ = [])\n",
                         "name", field_name);
          printer->Print("a.append($type$.fromReader(r))\n",
                         "type", field->message_type()->full_name());
        } else {
          printer->Print("m.$name$ = $type$.fromReader(r)\n",
                         "type", field->message_type()->full_name(),
                         "name", field_name);
        }

        printer->Print("r.popLimit(limit)\n");
      } else {
        std::string read_func;
        if (field->type() == google::protobuf::FieldDescriptor::TYPE_BOOL) {
          read_func = "readBool()";
        } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_INT32) {
          read_func = "readVarInt()";
        } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_FLOAT) {
          read_func = "readFloat32()";
        } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_DOUBLE) {
          read_func = "readFloat64()";
        } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_STRING) {
          read_func = "readString()";
        } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_ENUM) {
          read_func = "readVarInt()";
        } else {
          read_func = "undefined";
        }

        if (field->label() == google::protobuf::FieldDescriptor::LABEL_REPEATED) {
          printer->Print("var a = this.$name$\n"
                         "if (!a) {\n",
                         "name", field_name);
          printer->Indent();

          printer->Print("a = this.$name$ = []\n",
                         "name", field_name);

          printer->Outdent();
          printer->Print("}\n");
          printer->Print("a.append(r.$read_func$)\n",
                         "read_func", read_func,
                         "name", field_name);
        } else {
          printer->Print("m.$name$ = r.$read_func$\n",
                         "read_func", read_func,
                         "name", field_name);
        }
      }

      printer->Print("break\n");

      printer->Outdent();
      printer->Print("}\n");
    }

    printer->Outdent();
    printer->Print("}\n");
    printer->Outdent();
    printer->Print("}\n");
  }

  printer->Print("m.sizeInBytes = sizeInBytesOf$type$(m)\n",
                 "type", message->full_name());
  printer->Print("return Object.freeze(m)\n");

  printer->Outdent();
  printer->Print("}\n");
}

void CodeGenerator::GenMessage_builder(
    const google::protobuf::Descriptor *message,
    google::protobuf::io::Printer *printer) 
{
  printer->Print("$name$.builder = function() {\n",
                 "name", message->name());
  printer->Indent();
  printer->Print("return new $name$Builder()\n",
                 "name", message->name());
  printer->Outdent();
  printer->Print("}\n");
}

void CodeGenerator::GenMessageBuilder(
    const google::protobuf::Descriptor *message,
    google::protobuf::io::Printer *printer) 
{
  std::string builder_name = message->name() + "Builder";
  printer->Print("function $builder$() {\n",
                 "builder", builder_name);
  printer->Indent();
  printer->Print("this.m = undefined\n");
  printer->Outdent();
  printer->Print("}\n");
  printer->Print("$builder$.prototype = {\n",
                 "builder", builder_name);
  printer->Indent();

  printer->Print("clear: function() {\n");
  printer->Indent();
  printer->Print("this.m = undefined\n"
                 "return this\n");
  printer->Outdent();
  printer->Print("},\n");

  for (int i = 0; i < message->field_count(); ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);

    std::string field_name = field->camelcase_name();

    printer->Print("set$name$: function(v) {\n",
                   "name", ToCamelCase(field->name(), false));
    printer->Indent();
    printer->Print("var m = this.m || (this.m = new $name$())\n"
                   "m.$field_name$ = v\n"
                   "return this\n",
                   "name", message->name(),
                   "field_name", field_name);
    printer->Outdent();
    printer->Print("},\n");


    printer->Print("clear$name$: function() {\n",
                   "name", ToCamelCase(field->name(), false));
    printer->Indent();
    printer->Print("var m = this.m\n"
                   "if (m) {\n");
    printer->Indent();
    printer->Print("m.$field_name$ = undefined\n",
                   "field_name", field_name);
    printer->Outdent();
    printer->Print("}\n"
                   "return this\n");
    printer->Outdent();
    printer->Print("},\n");
  }

  printer->Print("build: function() {\n");
  printer->Indent();
  printer->Print("var m = this.m || new $name$()\n",
                 "name", message->name());
  printer->Print("m.sizeInBytes = sizeInBytesOf$type$(m)\n"
                 "m = Object.freeze(m)\n"
                 "this.m = undefined\n"
                 "return m\n",
                 "type", message->name());
  printer->Outdent();
  printer->Print("},\n");

  printer->Outdent();
  printer->Print("}\n");
}

void CodeGenerator::GenMessage_toWriter(
    const google::protobuf::Descriptor *message,
    google::protobuf::io::Printer *printer) 
{
  printer->Print("toWriter: function(w) {\n");
  printer->Indent();

  for (int i = 0; i < message->field_count(); ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);

    printer->Print("if (undefined !== this.$name$) {\n",
                   "name", field->camelcase_name());
    printer->Indent();

    std::string tag = std::to_string(WireFormatLite::MakeTag(field->number(), WireFormat::WireTypeForField(field)));
    std::string field_name = field->camelcase_name();

    if (field->label() == google::protobuf::FieldDescriptor::LABEL_REPEATED) {
      printer->Print("var a = this.$name$\n"
                     "for (var i = 0, iMax = a.length; i < iMax; i++) {\n",
                     "name", field_name);
      printer->Indent();
      printer->Print("var v = a[i]\n");
    } else {
      printer->Print("var v = this.$name$\n",
                     "name", field_name);
    }

    if (field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE) {
      printer->Print("w.writeVarInt($tag$)\n"
                     "w.writeVarInt(v.sizeInBytes)\n"
                     "v.toWriter(w)\n",
                     "tag", tag,
                     "name", field_name);
    } else {
      std::string write_func;
      if (field->type() == google::protobuf::FieldDescriptor::TYPE_BOOL) {
        write_func = "writeBool";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_INT32) {
        write_func = "writeVarInt";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_FLOAT) {
        write_func = "writeFloat32";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_DOUBLE) {
        write_func = "writeFloat64";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_STRING) {
        write_func = "writeString";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_ENUM) {
        write_func = "writeVarInt";
      } else {
        write_func = "undefined";
      }

      printer->Print("w.writeVarInt($tag$)\n"
                     "w.$write_func$(v)\n",
                     "write_func", write_func,
                     "tag", tag,
                     "name", field_name);
    }

    if (field->label() == google::protobuf::FieldDescriptor::LABEL_REPEATED) {
      printer->Outdent();
      printer->Print("}\n");
    }

    printer->Outdent();
    printer->Print("}\n");
  }

  printer->Outdent();
  printer->Print("},\n");
}

void CodeGenerator::GenMessage_sizeInBytes(
    const google::protobuf::Descriptor *message,
    google::protobuf::io::Printer *printer) 
{
  printer->Print("function sizeInBytesOf$name$(m) {\n",
                 "name", message->name());
  printer->Indent();

  printer->Print("var n = 0\n");

  for (int i = 0; i < message->field_count(); ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);

    printer->Print("if (undefined !== m.$name$) {\n",
                   "name", field->camelcase_name());
    printer->Indent();

    int tag = WireFormatLite::MakeTag(field->number(), WireFormat::WireTypeForField(field));
    std::string field_name = field->camelcase_name();

    if (field->label() == google::protobuf::FieldDescriptor::LABEL_REPEATED) {
      printer->Print("var a = m.$name$\n"
                     "for (var i = 0, iMax = a.length; i < iMax; i++) {\n",
                     "name", field_name);
      printer->Indent();
      printer->Print("var v = a[i]\n");
    } else {
      printer->Print("var v = m.$name$\n",
                     "name", field_name);
    }

    if (field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE) {
      printer->Print("n += $size_of_tag$ + sizeOfVarInt(v.sizeInBytes) + v.sizeInBytes\n",
                     "size_of_tag", std::to_string(sizeOfVarInt(tag)));
    } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_BOOL) {
      printer->Print("n += $size_of_tag$ + 1\n",
                     "size_of_tag", std::to_string(sizeOfVarInt(tag)));
    } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_INT32) {
      printer->Print("n += $size_of_tag$ + sizeOfVarInt(v)\n",
                     "size_of_tag", std::to_string(sizeOfVarInt(tag)));
    } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_FLOAT) {
      printer->Print("n += $size_of_tag$ + 4\n",
                     "size_of_tag", std::to_string(sizeOfVarInt(tag)));
    } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_DOUBLE) {
      printer->Print("n += $size_of_tag$ + 8\n",
                     "size_of_tag", std::to_string(sizeOfVarInt(tag)));
    } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_STRING) {
      printer->Print("n += $size_of_tag$ + sizeOfString(v)\n",
                     "size_of_tag", std::to_string(sizeOfVarInt(tag)));
    } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_ENUM) {
      printer->Print("n += $size_of_tag$ + sizeOfVarInt(v)\n",
                     "size_of_tag", std::to_string(sizeOfVarInt(tag)));
    } else {
      printer->Print("/*undefined*/\n");
    }
  
    if (field->label() == google::protobuf::FieldDescriptor::LABEL_REPEATED) {
      printer->Outdent();
      printer->Print("}\n");
    }
    
    printer->Outdent();
    printer->Print("}\n");
  }

  printer->Print("return n\n");

  printer->Outdent();
  printer->Print("}\n");
}

void CodeGenerator::GenEnum(
    const google::protobuf::EnumDescriptor *enum_desc,
    google::protobuf::io::Printer *printer) 
{
  printer->Print("var $name$ = {\n",
                 "name", enum_desc->full_name());
  printer->Indent();
  for (int i = 0; i < enum_desc->value_count(); ++i) {
    std::string format = "$key$: $value$,\n";
    if (i == enum_desc->value_count() - 1) {
      format = "$key$: $value$\n";
    }
    std::ostringstream number;
    number << enum_desc->value(i)->number();
    printer->Print(format.c_str(),
                   "key", enum_desc->value(i)->name(),
                   "value", number.str());
  }
  printer->Outdent();
  printer->Print("}\n\n");
}

}  // namespace js
}  // namespace compiler
}  // namespace protobuf
}  // namespace google
