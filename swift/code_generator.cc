// Copyright (c) 2010-2011 SameGoal LLC.
// All Rights Reserved.
// Author: Andy Hochhaus <ahochhaus@samegoal.com>

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "code_generator.h"

#include <string>
#include <iostream>  // NOLINT
#include <sstream>  // NOLINT

#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/printer.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream.h>
#include <google/protobuf/stubs/common.h>
#include <google/protobuf/wire_format.h>
#include <google/protobuf/wire_format_lite_inl.h>

namespace google { namespace protobuf { namespace compiler { namespace js {
using internal::WireFormat;
using internal::WireFormatLite;

namespace {

string ToCamelCase(const string& input, bool lower_first) {
  bool capitalize_next = !lower_first;
  string result;
  result.reserve(input.size());

  for (int i = 0; i < input.size(); i++) {
    if (input[i] == '_') {
      capitalize_next = true;
    } else if (capitalize_next) {
      // Note:  I distrust ctype.h due to locales.
      if ('a' <= input[i] && input[i] <= 'z') {
        result.push_back(input[i] - 'a' + 'A');
      } else {
        result.push_back(input[i]);
      }
      capitalize_next = false;
    } else {
      result.push_back(input[i]);
    }
  }

  // Lower-case the first letter.
  if (lower_first && !result.empty() && 'A' <= result[0] && result[0] <= 'Z') {
      result[0] = result[0] - 'A' + 'a';
  }

  return result;
}

int sizeOfVarInt(long long v) {
  int n = 0;
  do {
    v >>= 7;
    n++;
  } while (v > 0);
  return n;
}

string SwiftTypeForField(const google::protobuf::FieldDescriptor* field) {
  string type;
  switch (field->type()) {
  case google::protobuf::FieldDescriptor::TYPE_BOOL:
    type = "Bool"; 
    break;
  case google::protobuf::FieldDescriptor::TYPE_INT32:
    type = "Int"; 
    break;
  case google::protobuf::FieldDescriptor::TYPE_FLOAT:
    type = "Float32"; 
    break;
  case google::protobuf::FieldDescriptor::TYPE_DOUBLE:
    type = "Float64"; 
    break;
  case google::protobuf::FieldDescriptor::TYPE_STRING:
    type = "String"; 
    break;
  default:
    type = "/* unknown */";
    break;
  }
  if (field->is_optional()) {
    type = type + "?";
  }
  return type;
}

} // namespace

CodeGenerator::CodeGenerator(const std::string &name)
    : name_(name) {}

CodeGenerator::~CodeGenerator() {}

bool CodeGenerator::Generate(
    const google::protobuf::FileDescriptor *file,
    const std::string &/* parameter */,
    google::protobuf::compiler::OutputDirectory *output_directory,
    std::string *error) const {

  const std::string file_name = file->name();
  std::string output_file_name = file->name();
  std::size_t loc = output_file_name.rfind(".");
  output_file_name.erase(loc, output_file_name.length() - loc);
  output_file_name.append(".pb.swift");

  google::protobuf::internal::scoped_ptr<
      google::protobuf::io::ZeroCopyOutputStream> output(
          output_directory->Open(output_file_name));
  google::protobuf::io::Printer printer(output.get(), '$');
  printer.Print(
      "// Generated by the protocol buffer compiler.  DO NOT EDIT!\n");
  printer.Print("// source: $file_name$\n", "file_name", file_name);
  printer.Print("\n");
  printer.Print(
      "/**\n"
      " * @fileoverview Generated Protocol Buffer code for file $file_name$.\n"
      " */\n", "file_name", file_name);

  for (int i = 0; i < file->message_type_count(); ++i) {
    CodeGenerator::GenDescriptor(
        file->message_type(i),
        &printer);
  }

/*
  for (int i = 0; i < file->enum_type_count(); ++i) {
    CodeGenerator::GenEnum(
        file->enum_type(i),
        &printer);
  }

  printer.Print("function sizeOfVarInt(v) {\n");
  printer.Indent();
  printer.Print("var n = 0\n");
  printer.Print("do {\n");
  printer.Indent();
  printer.Print("v >>= 7\n");
  printer.Print("n++\n");
  printer.Outdent();
  printer.Print("} while (v > 0)\n");
  printer.Print("return n\n");
  printer.Outdent();
  printer.Print("}\n");
  printer.Print("\n");

  printer.Print("function sizeOfString(s) {\n");
  printer.Indent();
  printer.Print("var b = 0, i = 0, c\n");
  printer.Print("while(c=s.charCodeAt(i++)){b+=c>>11?3:c>>7?2:1}\n");
  printer.Print("return sizeOfVarInt(b) + b\n");
  printer.Outdent();
  printer.Print("}\n");
  printer.Print("\n");

  for (int i = 0; i < file->message_type_count(); ++i) {
    const google::protobuf::Descriptor *message = file->message_type(i);
    printer.Print("exports.$name$ = $name$\n",
                  "name", message->name());
  }
  for (int i = 0; i < file->enum_type_count(); ++i) {
    const google::protobuf::EnumDescriptor *enum_desc = file->enum_type(i);
    printer.Print("exports.$name$ = $name$\n",
                  "name", enum_desc->name());
  }
*/

  if (printer.failed()) {
    *error = "CodeGenerator detected write error.";
    return false;
  }

  return true;
}

void CodeGenerator::GenDescriptor(
    const google::protobuf::Descriptor *message,
    google::protobuf::io::Printer *printer) 
{
  printer->Print("public class $name$ {\n",
                 "name", message->name());
  printer->Indent();
  printer->Print("public let sizeInBytes: Int\n");
  for (int i = 0; i < message->field_count(); ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);
    printer->Print("public let $name$: $type$\n",
                   "name", field->camelcase_name(),
                   "type", SwiftTypeForField(field));
  }
  printer->Print("\n");

  printer->Print("init(sizeInBytes: Int, ");
  for (int i = 0, lastI = message->field_count() - 1; i <= lastI; ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);
    printer->Print("$name$: $type$",
                   "name", field->camelcase_name(),
                   "type", SwiftTypeForField(field));
    if (i != lastI) {
      printer->Print(", ");
    }
  }
  printer->Print(") {\n");
  printer->Indent();
  printer->Print("self.sizeInBytes = sizeInBytes\n");
  for (int i = 0; i < message->field_count(); ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);
    printer->Print("self.$name$ = $name$\n",
                   "name", field->camelcase_name());
  }
  printer->Outdent();
  printer->Print("}\n\n");

  CodeGenerator::GenMessage_toWriter(message, printer);
  CodeGenerator::GenMessage_fromReader(message, printer);
  CodeGenerator::GenMessage_sizeInBytes(message, printer);

  printer->Outdent();
  printer->Print("}\n");

/*
  CodeGenerator::GenMessage_fromReader(message, printer);
  CodeGenerator::GenMessage_builder(message, printer);
  CodeGenerator::GenMessage_sizeInBytes(message, printer);

  printer->Outdent();
  printer->Print("}\n");

  CodeGenerator::GenMessageBuilder(message, printer);

  for (int i = 0; i < message->nested_type_count(); ++i) {
    const google::protobuf::Descriptor *nested_type = message->nested_type(i);
    printer->Print("$name$.$nested_name$ = function(){\n",
                   "name", message->name(),
                   "nested_name", nested_type->name());
    printer->Indent();
    CodeGenerator::GenDescriptor(
        nested_type,
        printer);
    printer->Print("return $nested_name$\n",
                   "nested_name", nested_type->name());
    printer->Outdent();
    printer->Print("}()\n");
  }

  for (int i = 0; i < message->enum_type_count(); ++i) {
    const google::protobuf::EnumDescriptor *enum_desc = message->enum_type(i);
    printer->Print("$name$.$nested_name$ = {\n",
                   "name", message->name(),
                   "nested_name", enum_desc->name());
    printer->Indent();
    for (int i = 0; i < enum_desc->value_count(); ++i) {
      std::string format = "$key$: $value$,\n";
      if (i == enum_desc->value_count() - 1) {
        format = "$key$: $value$\n";
      }
      std::ostringstream number;
      number << enum_desc->value(i)->number();
      printer->Print(format.c_str(),
                     "key", enum_desc->value(i)->name(),
                     "value", number.str());
    }
    printer->Outdent();
    printer->Print("}\n");
  }
*/

  printer->Print("\n");
}

void CodeGenerator::GenMessage_fromReader(
    const google::protobuf::Descriptor *message,
    google::protobuf::io::Printer *printer) 
{
  printer->Print("public class func fromReader(r: Reader) -> $name$ {\n",
                 "name", message->name());
  printer->Indent();
  for (int i = 0; i < message->field_count(); ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);

    string default_value = "/* default value unknown */";
    switch (field->cpp_type()) {
      case internal::WireFormatLite::CPPTYPE_INT32:
        default_value = field->is_optional() ? "nil" : "0";
        if (field->has_default_value()) { 
          default_value = to_string(field->default_value_int32());
        }
        break;
      case internal::WireFormatLite::CPPTYPE_STRING:
        default_value = field->is_optional() ? "nil" : "\"\"";
        if (field->has_default_value()) { 
          default_value = field->default_value_string();
        }
      default: 
        break;
    }

    printer->Print("var $name$: $type$ = $default_value$\n",
                   "name", field->camelcase_name(),
                   "type", SwiftTypeForField(field),
                   "default_value", default_value);
  }
  printer->Print("\n");

  printer->Print("loop: while true {\n");
  printer->Indent();
  printer->Print("switch r.readVarInt() {\n");
  for (int i = 0; i < message->field_count(); ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);

    string tag = to_string(WireFormatLite::MakeTag(field->number(), WireFormat::WireTypeForField(field)));

    printer->Print("case $tag$:\n",
                   "tag", tag);
    printer->Indent();

    {
      std::string read_func;
      if (field->type() == google::protobuf::FieldDescriptor::TYPE_BOOL) {
        read_func = "readBool";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_INT32) {
        read_func = "readVarInt";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_FLOAT) {
        read_func = "readFloat32";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_DOUBLE) {
        read_func = "readFloat64";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_STRING) {
        read_func = "readString";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_ENUM) {
        read_func = "readVarInt";
      } else {
        read_func = "undefined";
      }

      printer->Print("$name$ = r.$read_func$()\n",
                     "read_func",read_func,
                     "name", field->camelcase_name());
    }


    printer->Outdent();
  }
  printer->Print("default:\n");
  printer->Indent();
  printer->Print("break loop\n");
  printer->Outdent();
  //
  printer->Print("}\n");
  printer->Outdent();
  printer->Print("}\n");

  printer->Print("\n");
  printer->Print("let sizeInBytes = $name$.sizeInBytes(",
                  "name", message->name());
  for (int i = 0, lastI = message->field_count() - 1; i <= lastI; ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);
    if(i == 0){
      printer->Print("$name$",
                   "name", field->camelcase_name());
    } else {
      printer->Print("$name$: $name$",
                     "name", field->camelcase_name());
    }
    if (i != lastI) {
      printer->Print(", ");
    }
  }
  printer->Print(")\n");

  //return TestMessage(sizeInBytes: sizeInBytes, integer: integer, string: string)

  printer->Print("return $name$(sizeInBytes: sizeInBytes, ",
                  "name", message->name());
  for (int i = 0, lastI = message->field_count() - 1; i <= lastI; ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);
    printer->Print("$name$: $name$",
                   "name", field->camelcase_name());
    if (i != lastI) {
      printer->Print(", ");
    }
  }
  printer->Print(")\n");

  printer->Outdent();
  printer->Print("}\n\n");
}

// void CodeGenerator::GenMessage_builder(
//     const google::protobuf::Descriptor *message,
//     google::protobuf::io::Printer *printer) 
// {
//   printer->Print("$name$.builder = function() {\n",
//                  "name", message->name());
//   printer->Indent();
//   printer->Print("return new $name$Builder()\n",
//                  "name", message->name());
//   printer->Outdent();
//   printer->Print("}\n");
// }

// void CodeGenerator::GenMessageBuilder(
//     const google::protobuf::Descriptor *message,
//     google::protobuf::io::Printer *printer) 
// {
//   std::string builder_name = message->name() + "Builder";
//   printer->Print("function $builder$() {\n",
//                  "builder", builder_name);
//   printer->Indent();
//   printer->Print("this.m = undefined\n");
//   printer->Outdent();
//   printer->Print("}\n");
//   printer->Print("$builder$.prototype = {\n",
//                  "builder", builder_name);
//   printer->Indent();

//   printer->Print("clear: function() {\n");
//   printer->Indent();
//   printer->Print("this.m = undefined\n"
//                  "return this\n");
//   printer->Outdent();
//   printer->Print("},\n");

//   for (int i = 0; i < message->field_count(); ++i) {
//     const google::protobuf::FieldDescriptor *field = message->field(i);

//     std::string field_name = field->camelcase_name();

//     printer->Print("set$name$: function(v) {\n",
//                    "name", ToCamelCase(field->name(), false));
//     printer->Indent();
//     printer->Print("var m = this.m || (this.m = new $name$())\n"
//                    "m.$field_name$ = v\n"
//                    "return this\n",
//                    "name", message->name(),
//                    "field_name", field_name);
//     printer->Outdent();
//     printer->Print("},\n");


//     printer->Print("clear$name$: function() {\n",
//                    "name", ToCamelCase(field->name(), false));
//     printer->Indent();
//     printer->Print("var m = this.m\n"
//                    "if (m) {\n");
//     printer->Indent();
//     printer->Print("m.$field_name$ = undefined\n",
//                    "field_name", field_name);
//     printer->Outdent();
//     printer->Print("}\n"
//                    "return this\n");
//     printer->Outdent();
//     printer->Print("},\n");
//   }

//   printer->Print("build: function() {\n");
//   printer->Indent();
//   printer->Print("var m = this.m || new $name$()\n",
//                  "name", message->name());
//   printer->Print("m.sizeInBytes = sizeInBytesOf$type$(m)\n"
//                  "m = Object.freeze(m)\n"
//                  "this.m = undefined\n"
//                  "return m\n",
//                  "type", message->name());
//   printer->Outdent();
//   printer->Print("},\n");

//   printer->Outdent();
//   printer->Print("}\n");
// }

void CodeGenerator::GenMessage_toWriter(
    const google::protobuf::Descriptor *message,
    google::protobuf::io::Printer *printer) 
{
  printer->Print("public func toWriter(w: Writer) {\n");
  printer->Indent();

  for (int i = 0; i < message->field_count(); ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);
    string name = "self." + field->camelcase_name();

    if (field->is_optional()) {
      printer->Print("if let v = $name$ {\n",
                     "name", name);
      printer->Indent();
      name = "v";
    }

    string tag = to_string(WireFormatLite::MakeTag(field->number(), WireFormat::WireTypeForField(field)));
    
    {
      std::string write_func;
      if (field->type() == google::protobuf::FieldDescriptor::TYPE_BOOL) {
        write_func = "writeBool";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_INT32) {
        write_func = "writeVarInt";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_FLOAT) {
        write_func = "writeFloat32";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_DOUBLE) {
        write_func = "writeFloat64";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_STRING) {
        write_func = "writeString";
      } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_ENUM) {
        write_func = "writeVarInt";
      } else {
        write_func = "undefined";
      }

      printer->Print("w.writeVarInt($tag$)\n"
                     "w.$write_func$($name$)\n",
                     "write_func", write_func,
                     "tag", tag,
                     "name", name);
    }

    if (field->is_optional()) {
      printer->Outdent();
      printer->Print("}\n");
    }

    if (i < message->field_count() - 1) {
      printer->Print("\n");
    }
  }

  printer->Outdent();
  printer->Print("}\n\n");
}

void CodeGenerator::GenMessage_sizeInBytes(
    const google::protobuf::Descriptor *message,
    google::protobuf::io::Printer *printer) 
{
  printer->Print("class func sizeInBytes(",
                 "name", message->name());
  for (int i = 0, lastI = message->field_count() - 1; i <= lastI; ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);
    printer->Print("$name$: $type$",
                   "name", field->camelcase_name(),
                   "type", SwiftTypeForField(field));
    if (i != lastI) {
      printer->Print(", ");
    }
  }
  printer->Print(") -> Int {\n");
  printer->Indent();
  
  printer->Print("var n = 0\n\n");

  for (int i = 0; i < message->field_count(); ++i) {
    const google::protobuf::FieldDescriptor *field = message->field(i);
    string name = field->camelcase_name();

    if (field->is_optional()) {
      printer->Print("if let v = $name$ {\n",
                     "name", name);
      printer->Indent();
      name = "v";
    }

    int tag = WireFormatLite::MakeTag(field->number(), WireFormat::WireTypeForField(field));
    string size_of_tag = std::to_string(sizeOfVarInt(tag));

    std::string write_func;
    if (field->type() == google::protobuf::FieldDescriptor::TYPE_BOOL) {
      printer->Print("n += $size_of_tag$ + 1\n",
                     "size_of_tag", size_of_tag);
    } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_INT32) {
      printer->Print("n += $size_of_tag$ + sizeOfVarInt(Int($name$))\n",
                     "size_of_tag", size_of_tag,
                     "name", name);
    } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_FLOAT) {
      printer->Print("n += $size_of_tag$ + 4\n",
                     "size_of_tag", size_of_tag);
    } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_DOUBLE) {
      printer->Print("n += $size_of_tag$ + 8\n",
                     "size_of_tag", size_of_tag);
    } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_STRING) {
      printer->Print("n += $size_of_tag$ + sizeOfString($name$)\n",
                     "size_of_tag", size_of_tag,
                     "name", name);
    } else {
      // TODO: Other types
    }

    if (field->is_optional()) {
      printer->Outdent();
      printer->Print("}\n");
    }

    printer->Print("\n");
  }

  printer->Print("return n\n");

  //   int tag = WireFormatLite::MakeTag(field->number(), WireFormat::WireTypeForField(field));
  //   std::string field_name = field->camelcase_name();

  //   if (field->label() == google::protobuf::FieldDescriptor::LABEL_REPEATED) {
  //     printer->Print("var a = m.$name$\n"
  //                    "for (var i = 0, iMax = a.length; i < iMax; i++) {\n",
  //                    "name", field_name);
  //     printer->Indent();
  //     printer->Print("var v = a[i]\n");
  //   } else {
  //     printer->Print("var v = m.$name$\n",
  //                    "name", field_name);
  //   }

  //   if (field->type() == google::protobuf::FieldDescriptor::TYPE_MESSAGE) {
  //     printer->Print("n += $size_of_tag$ + sizeOfVarInt(v.sizeInBytes) + v.sizeInBytes\n",
  //                    "size_of_tag", std::to_string(sizeOfVarInt(tag)));
  //   } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_BOOL) {
  //     printer->Print("n += $size_of_tag$ + 1\n",
  //                    "size_of_tag", std::to_string(sizeOfVarInt(tag)));
  //   } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_INT32) {
  //     printer->Print("n += $size_of_tag$ + sizeOfVarInt(v)\n",
  //                    "size_of_tag", std::to_string(sizeOfVarInt(tag)));
  //   } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_FLOAT) {
  //     printer->Print("n += $size_of_tag$ + 4\n",
  //                    "size_of_tag", std::to_string(sizeOfVarInt(tag)));
  //   } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_DOUBLE) {
  //     printer->Print("n += $size_of_tag$ + 8\n",
  //                    "size_of_tag", std::to_string(sizeOfVarInt(tag)));
  //   } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_STRING) {
  //     printer->Print("n += $size_of_tag$ + sizeOfString(v)\n",
  //                    "size_of_tag", std::to_string(sizeOfVarInt(tag)));
  //   } else if (field->type() == google::protobuf::FieldDescriptor::TYPE_ENUM) {
  //     printer->Print("n += $size_of_tag$ + sizeOfVarInt(v)\n",
  //                    "size_of_tag", std::to_string(sizeOfVarInt(tag)));
  //   } else {
  //     printer->Print("/*undefined*/\n");
  //   }
  
  //   if (field->label() == google::protobuf::FieldDescriptor::LABEL_REPEATED) {
  //     printer->Outdent();
  //     printer->Print("}\n");
  //   }
    
  //   printer->Outdent();
  //   printer->Print("}\n");
  // }

  // printer->Print("return n\n");

  printer->Outdent();
  printer->Print("}\n");
}

void CodeGenerator::GenEnum(
    const google::protobuf::EnumDescriptor *enum_desc,
    google::protobuf::io::Printer *printer) 
{
  printer->Print("var $name$ = {\n",
                 "name", enum_desc->full_name());
  printer->Indent();
  for (int i = 0; i < enum_desc->value_count(); ++i) {
    std::string format = "$key$: $value$,\n";
    if (i == enum_desc->value_count() - 1) {
      format = "$key$: $value$\n";
    }
    std::ostringstream number;
    number << enum_desc->value(i)->number();
    printer->Print(format.c_str(),
                   "key", enum_desc->value(i)->name(),
                   "value", number.str());
  }
  printer->Outdent();
  printer->Print("}\n\n");
}

}  // namespace js
}  // namespace compiler
}  // namespace protobuf
}  // namespace google
